'use client';
export { LocationSearch as default } from './LocationSearch';

/*
// Cleaned-up LocationSearch component with all logic and refs/hooks inside the function.

import { useEffect, useRef, useCallback, useState } from 'react';

declare global {
  interface Window {
    google: any;
    initMap?: () => void;
  }
}

interface LatLng {
  lat: () => number;
  lng: () => number;
}

export interface Place {
  name?: string;
  formatted_address?: string;
  geometry?: {
    location: LatLng;
  };
  place_id?: string;
  types?: string[];
}

interface LocationSearchProps {
  onPlaceSelected: (place: Place) => void;
  placeholder?: string;
  className?: string;
}

export function LocationSearch({
  onPlaceSelected,
  placeholder = 'Search for places...',
  className = '',
}: LocationSearchProps) {
  const inputRef = useRef<HTMLInputElement>(null);
  const autocompleteRef = useRef<any>(null);
  const mapRef = useRef<any>(null);
  const hiddenMapDivRef = useRef<HTMLDivElement | null>(null);
  const cleanupRef = useRef<(() => void) | null>(null);
  const [selectedPlace, setSelectedPlace] = useState<Place | null>(null);

  // Initialize Google Places Autocomplete
  const initializeAutocomplete = useCallback(() => {
    if (!inputRef.current || !window.google?.maps?.places) {
      return;
    }
    // Create a hidden map div if it doesn't exist
    if (!hiddenMapDivRef.current) {
      const hiddenMapDiv = document.createElement('div');
      hiddenMapDiv.style.display = 'none';
      document.body.appendChild(hiddenMapDiv);
      hiddenMapDivRef.current = hiddenMapDiv;
      mapRef.current = new window.google.maps.Map(hiddenMapDiv, {
        center: { lat: 28.6139, lng: 77.209 },
        zoom: 13,
      });
    }
    // Clean up existing autocomplete
    if (autocompleteRef.current) {
      window.google.maps.event.clearInstanceListeners(autocompleteRef.current);
      autocompleteRef.current = null;
    }
    autocompleteRef.current = new window.google.maps.places.Autocomplete(
      inputRef.current,
      {
        types: ['geocode', 'establishment'],
        componentRestrictions: { country: 'in' },
        fields: [
          'address_components',
          'formatted_address',
          'geometry',
          'name',
          'place_id',
          'types',
        ],
      }
    );

    // Place changed handler
    const handlePlaceChanged = () => {
      if (!autocompleteRef.current) return;
      const place = autocompleteRef.current.getPlace();
      if (place && place.geometry && place.geometry.location) {
        const selected: Place = {
          name: place.name,
          formatted_address: place.formatted_address,
          geometry: {
            location: {
              lat: () => place.geometry.location.lat(),
              lng: () => place.geometry.location.lng(),
            },
          },
          place_id: place.place_id,
          types: place.types,
        };
        setSelectedPlace(selected);
        onPlaceSelected(selected);
      }
    };
    autocompleteRef.current.addListener('place_changed', handlePlaceChanged);

    // Prevent form submission on Enter
    const handleKeyDown = (e: KeyboardEvent) => {
      if (e.key === 'Enter' && document.activeElement === inputRef.current) {
        e.preventDefault();
        e.stopPropagation();
      }
    };
    inputRef.current.addEventListener('keydown', handleKeyDown);

    // Cleanup
    cleanupRef.current = () => {
      if (autocompleteRef.current) {
        window.google.maps.event.clearInstanceListeners(autocompleteRef.current);
      }
      inputRef.current?.removeEventListener('keydown', handleKeyDown);
    };
    return cleanupRef.current;
  }, [onPlaceSelected]);

  // Load Google Maps script
  useEffect(() => {
    if (window.google?.maps?.places) {
      initializeAutocomplete();
      return;
    }
    const script = document.createElement('script');
    script.src = `https://maps.googleapis.com/maps/api/js?key=${process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}&libraries=places&callback=initMap`;
    script.async = true;
    script.defer = true;
    window.initMap = initializeAutocomplete;
    script.onerror = (error) => {
      console.error('Error loading Google Maps script:', error);
    };
    document.head.appendChild(script);
    return () => {
      if (window.google?.maps?.event) {
        if (autocompleteRef.current) {
          window.google.maps.event.clearInstanceListeners(autocompleteRef.current);
        }
      }
      if (hiddenMapDivRef.current) {
        document.body.removeChild(hiddenMapDivRef.current);
      }
      window.initMap = undefined;
    };
  }, [initializeAutocomplete]);

  // Dropdown styling and event propagation prevention
  useEffect(() => {
    const style = document.createElement('style');
    style.innerHTML = `
      .pac-container {
        z-index: 10000 !important;
        border-radius: 0.5rem !important;
        box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06) !important;
        margin-top: 0.5rem !important;
        font-family: inherit !important;
        background-color: white !important;
        pointer-events: auto !important;
      }
      .pac-item {
        padding: 0.75rem 1rem !important;
        cursor: pointer !important;
        border-top: 1px solid #e5e7eb !important;
        transition: background-color 0.2s !important;
        font-size: 0.875rem !important;
        color: #374151 !important;
        pointer-events: auto !important;
      }
      .pac-item:first-child {
        border-top: none !important;
      }
      .pac-item:hover {
        background-color: #f3f4f6 !important;
      }
      .pac-item-query {
        font-size: 0.875rem !important;
        color: #111827 !important;
        padding-right: 3px;
      }
      .pac-icon {
        display: none !important;
      }
      .pac-matched {
        font-weight: 500 !important;
        color: #111827 !important;
      }`;
    document.head.appendChild(style);
    const handleDocumentClick = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (target.closest && target.closest('.pac-container')) {
        e.stopPropagation();
        e.preventDefault();
      }
    };
    const handleDocumentMouseDown = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (target.closest && target.closest('.pac-container')) {
        e.stopPropagation();
      }
    };
    document.addEventListener('click', handleDocumentClick, true);
    document.addEventListener('mousedown', handleDocumentMouseDown, true);
    return () => {
      document.head.removeChild(style);
      document.removeEventListener('click', handleDocumentClick, true);
      document.removeEventListener('mousedown', handleDocumentMouseDown, true);
    };
  }, []);

  // Clean up on unmount
  useEffect(() => {
    return () => {
      if (cleanupRef.current) {
        cleanupRef.current();
      }
      if (hiddenMapDivRef.current) {
        document.body.removeChild(hiddenMapDivRef.current);
      }
    };
  }, []);

  // Handle input focus to show suggestions
  const handleInputFocus = () => {
    if (inputRef.current) {
      const inputEvent = new Event('input', { bubbles: true });
      inputRef.current.dispatchEvent(inputEvent);
    }
  };

  // Prevent drawer closing and event propagation
  const handleInputClick = (e: React.MouseEvent) => {
    e.stopPropagation();
  };
  const handleInputMouseDown = (e: React.MouseEvent) => {
    e.stopPropagation();
  };

  return (
    <div
      className={`relative w-full ${className}`}
      onClick={handleInputClick}
      onMouseDown={handleInputMouseDown}
    >
      <div className="relative">
        <input
          ref={inputRef}
          type="text"
          placeholder={placeholder}
          onClick={handleInputClick}
          onMouseDown={handleInputMouseDown}
          onFocus={handleInputFocus}
          className="w-full rounded-md border border-gray-300 pl-10 pr-4 py-2 focus:border-pink-500 focus:ring-1 focus:ring-pink-500"
        />
        <div className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <circle cx="11" cy="11" r="8" />
            <path d="m21 21-4.3-4.3" />
          </svg>
        </div>
      </div>
      {selectedPlace && (
        <div className="mt-2 text-sm text-gray-600">
          Selected: {selectedPlace.name || selectedPlace.formatted_address}
        </div>
      )}
    </div>
  );
}

// Load Google Maps script with error handling
      .pac-item-query {
        font-size: 0.875rem !important;
        color: #111827 !important;
        padding-right: 3px;
      }
      
      .pac-icon {
        display: none !important;
      }
      
      .pac-matched {
        font-weight: 500 !important;
        color: #111827 !important;
      }`;
      
    document.head.appendChild(style);
    
    // Add global click handler to prevent event propagation from dropdown
    const handleDocumentClick = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (target.closest && target.closest('.pac-container')) {
        e.stopPropagation();
        e.preventDefault();
      }
    };
    
    // Add mousedown handler to prevent drawer from closing
    const handleDocumentMouseDown = (e: MouseEvent) => {
      const target = e.target as HTMLElement;
      if (target.closest && target.closest('.pac-container')) {
        e.stopPropagation();
      }
    };
    
    document.addEventListener('click', handleDocumentClick, true);
    document.addEventListener('mousedown', handleDocumentMouseDown, true);
    
    return () => {
      document.head.removeChild(style);
      document.removeEventListener('click', handleDocumentClick, true);
      document.removeEventListener('mousedown', handleDocumentMouseDown, true);
    };
    document.head.appendChild(style);

    return () => {
      document.head.removeChild(style);
    };
  }, []);

  // Load Google Maps script with error handling
  useEffect(() => {
    const loadGoogleMapsScript = () => {
      if (window.google && window.google.maps && window.google.maps.places) {
        initializeAutocomplete();
        return;
      }

      // Remove any existing script with the same src to prevent duplicates
      const existingScript = document.querySelector('script[src*="maps.googleapis.com/maps/api/js"]');
      if (existingScript) {
        existingScript.remove();
      }

      const script = document.createElement('script');
      script.src = `https://maps.googleapis.com/maps/api/js?key=${process.env.NEXT_PUBLIC_GOOGLE_MAPS_API_KEY}&libraries=places&callback=initMap`;
      script.async = true;
      script.defer = true;
      
      // Set up the global initMap function
      window.initMap = initializeAutocomplete;
      
      script.onerror = (error) => {
        console.error('Error loading Google Maps script:', error);
      };
      
      document.head.appendChild(script);
    };

    loadGoogleMapsScript();

    return () => {
      // Clean up event listeners and global function
      if (window.google && window.google.maps && window.google.maps.event) {
        if (autocompleteRef.current) {
          window.google.maps.event.clearInstanceListeners(autocompleteRef.current);
        }
        if (mapRef.current) {
          window.google.maps.event.clearInstanceListeners(mapRef.current);
        }
      }
      window.initMap = undefined;
    };
  }, []);

  const initializeAutocomplete = () => {
    if (!inputRef.current) {
      console.error('Input ref not available');
      return;
    }

    if (!window.google?.maps?.places) {
      console.error('Google Maps JavaScript API not fully loaded');
      return;
    }
    
    // Clean up any existing autocomplete instance
    if (autocompleteRef.current) {
      window.google.maps.event.clearInstanceListeners(autocompleteRef.current);
      autocompleteRef.current = null;
    }

    // Clean up any existing autocomplete instance
    if (autocompleteRef.current) {
      window.google.maps.event.clearInstanceListeners(autocompleteRef.current);
      autocompleteRef.current = null;
    }

    try {
      // Create a hidden map (required for Autocomplete)
      const hiddenMapDiv = document.createElement('div');
      hiddenMapDiv.style.display = 'none';
      document.body.appendChild(hiddenMapDiv);

      // Create a map instance (required for Autocomplete)
      mapRef.current = new window.google.maps.Map(hiddenMapDiv, {
        center: { lat: 28.6139, lng: 77.209 }, // Default to New Delhi
        zoom: 13,
      });

      // Create the autocomplete with more comprehensive configuration
      autocompleteRef.current = new window.google.maps.places.Autocomplete(
        inputRef.current,
        {
          types: ['geocode', 'establishment'],
          componentRestrictions: { country: 'in' },
          fields: ['address_components', 'formatted_address', 'geometry', 'name', 'place_id', 'types'],
        }
      );

      // Prevent clicks on the dropdown from being intercepted
      document.addEventListener('click', (e) => {
        if (e.target && (e.target as HTMLElement).closest && 
            (e.target as HTMLElement).closest('.pac-container')) {
          e.stopPropagation();
        }
      }, true);

      // Add place_changed event listener with null check
      const autocomplete = autocompleteRef.current;
      if (autocomplete) {
        autocomplete.addListener('place_changed', () => {
          handlePlaceChanged();
        });
        
        // Prevent clicks on the dropdown from being intercepted
        window.google.maps.event.addDomListener(inputRef.current, 'keydown', (e: KeyboardEvent) => {
          if (e.key === 'Enter' && document.activeElement === inputRef.current) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      // Handle click events on the input to show suggestions
      const handleInputClick = (e: MouseEvent) => {
        e.stopPropagation();
      };

      // Add click event listener to the input
      if (inputRef.current) {
        inputRef.current.addEventListener('click', handleInputClick);
      }

      // Clean up function
      return () => {
        if (inputRef.current) {
          inputRef.current.removeEventListener('click', handleInputClick);
        }
        document.body.removeChild(hiddenMapDiv);
      };
    } catch (error) {
      console.error('Error initializing autocomplete:', error);
    }
  };

  const handlePlaceChanged = () => {
    try {
      if (!autocompleteRef.current) {
        console.error('Autocomplete not initialized');
        return;
      }

      const place = autocompleteRef.current.getPlace();
      
      if (!place) {
        console.log('No place selected');
        return;
      }

      if (!place.geometry || !place.geometry.location) {
        console.log('No geometry available for the selected place');
        return;
      }

      // Create a simplified place object with only the properties we need
      const simplifiedPlace = {
        name: place.name || '',
        formatted_address: place.formatted_address || '',
        geometry: {
          location: {
            lat: place.geometry.location.lat(),
            lng: place.geometry.location.lng()
          }
        },
        place_id: place.place_id,
        types: place.types
      };

      setSelectedPlace(simplifiedPlace);
      onPlaceSelected(simplifiedPlace);
    } catch (error) {
      console.error('Error handling place selection:', error);
    }
  };

  const handleInputFocus = () => {
    if (inputRef.current) {
      // Trigger a small input change to show suggestions
      const inputEvent = new Event('input', { bubbles: true });
      inputRef.current.dispatchEvent(inputEvent);
    }
  };

    // Clean up function
    return () => {
      if (inputRef.current) {
        inputRef.current.removeEventListener('click', handleInputClick);
      }
      document.body.removeChild(hiddenMapDiv);
    };
  } catch (error) {
    console.error('Error initializing autocomplete:', error);
  }
};

const handlePlaceChanged = () => {
  try {
    if (!autocompleteRef.current) {
      console.error('Autocomplete not initialized');
      return;
    }

    const place = autocompleteRef.current.getPlace();
    
    if (!place) {
      console.log('No place selected');
      return;
    }

    if (!place.geometry || !place.geometry.location) {
      console.log('No geometry available for the selected place');
      return;
    }

    // Create a simplified place object with only the properties we need
    const simplifiedPlace = {
      name: place.name || '',
      formatted_address: place.formatted_address || '',
      geometry: {
        location: {
          lat: place.geometry.location.lat(),
          lng: place.geometry.location.lng()
        }
      },
      place_id: place.place_id,
      types: place.types
    };

    setSelectedPlace(simplifiedPlace);
    onPlaceSelected(simplifiedPlace);
  } catch (error) {
    console.error('Error handling place selection:', error);
  }
};

const handleInputFocus = () => {
  if (inputRef.current) {
    // Trigger a small input change to show suggestions
    const inputEvent = new Event('input', { bubbles: true });
    inputRef.current.dispatchEvent(inputEvent);
  }
};

useEffect(() => {
  const handleClick = (e: MouseEvent) => {
    const target = e.target as HTMLElement;
    if (target.closest('.pac-container')) {
      e.stopPropagation();
      e.preventDefault();
    }
  };
  
  document.addEventListener('click', handleClick, true);
  return () => document.removeEventListener('click', handleClick, true);
}, []);

return (
  <div 
    className="relative w-full" 
    onClick={(e) => e.stopPropagation()}
    onMouseDown={(e) => e.stopPropagation()}
  >
    <div className="relative">
      <input
        ref={inputRef}
        type="text"
        placeholder={placeholder}
        onClick={(e) => e.stopPropagation()}
        onMouseDown={(e) => e.stopPropagation()}
        onFocus={() => {
          if (inputRef.current) {
            inputRef.current.value = '';
            const event = new Event('input', { bubbles: true });
            inputRef.current.dispatchEvent(event);
          }
        }}
        className={`w-full rounded-md border border-gray-300 pl-10 pr-4 py-2 focus:border-pink-500 focus:ring-1 focus:ring-pink-500 ${className}`}
      />
      <div className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400">
        <svg
          xmlns="http://www.w3.org/2000/svg"
          width="16"
          height="16"
          viewBox="0 0 24 24"
          fill="none"
          stroke="currentColor"
          strokeWidth="2"
          strokeLinecap="round"
          strokeLinejoin="round"
        >
          <circle cx="11" cy="11" r="8" />
          <path d="m21 21-4.3-4.3" />
        </svg>
          }}
          className={`w-full rounded-md border border-gray-300 pl-10 pr-4 py-2 focus:border-pink-500 focus:ring-1 focus:ring-pink-500 ${className}`}
        />
        <div className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-400">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            width="16"
            height="16"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            strokeWidth="2"
            strokeLinecap="round"
            strokeLinejoin="round"
          >
            <circle cx="11" cy="11" r="8" />
            <path d="m21 21-4.3-4.3" />
          </svg>
        </div>
      </div>
      {selectedPlace && (
        <div className="mt-2 text-sm text-gray-600">
          Selected: {selectedPlace.name || selectedPlace.formatted_address}
        </div>
      )}
    </div>
  );
}
